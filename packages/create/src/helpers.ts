import { cancel, isCancel, spinner } from '@clack/prompts';
import spawn from 'cross-spawn';
import fs from 'fs-extra';
import path from 'path';
import pc from 'picocolors';
import semver from 'semver';

import { HEXOS_VERSION, NEXTJS_VERSION, REACT_VERSION, TYPESCRIPT_VERSION } from './constants';
import { log } from './logger';
import type { CliLogLevel, LLMProvider, PackageManager } from './types';

/**
 * If project only contains files generated by GH, it's safe.
 * Also, if project contains remnant error logs from a previous
 * installation, lets remove them now.
 */
export function isSafeToCreateProjectIn(root: string, name: string) {
    const errorLogFilePatterns = ['npm-debug.log', 'pnpm-debug.log', 'yarn-error.log', 'yarn-debug.log'];
    const validFiles = [
        '.DS_Store',
        'Thumbs.db',
        '.git',
        '.gitignore',
        '.idea',
        'README.md',
        'LICENSE',
        '.hg',
        '.hgignore',
        '.hgcheck',
        '.npmignore',
        'node_modules',
        'package.json',
        'package-lock.json',
        'pnpm-lock.yaml',
    ];

    const conflicts = fs
        .readdirSync(root)
        .filter(file => !validFiles.includes(file))
        .filter(file => !/\.iml$/.test(file))
        .filter(file => !errorLogFilePatterns.some(pattern => file.indexOf(pattern) === 0));

    if (conflicts.length > 0) {
        log(`The directory ${pc.green(name)} contains files that could conflict:`, { newline: 'after' });
        for (const file of conflicts) {
            log(`  ${file}`);
        }
        log('Either try using a new directory name, or remove the files listed above.', {
            newline: 'before',
        });

        return false;
    }

    // Remove any remnant files from a previous installation
    const currentFiles = fs.readdirSync(path.join(root));
    currentFiles.forEach(file => {
        errorLogFilePatterns.forEach(errorLogFilePattern => {
            if (file.indexOf(errorLogFilePattern) === 0) {
                fs.removeSync(path.join(root, file));
            }
        });
    });
    return true;
}

export function scaffoldAlreadyExists(root: string): boolean {
    const scaffoldFiles = ['next.config.js', 'package.json', 'tsconfig.json'];
    const files = fs.readdirSync(root);
    return scaffoldFiles.every(scaffoldFile => files.includes(scaffoldFile));
}

export function checkNodeVersion(requiredVersion: string) {
    if (!semver.satisfies(process.version, requiredVersion)) {
        log(
            pc.red(
                `You are running Node ${process.version}. ` +
                    `Hexos requires Node ${requiredVersion} or higher. ` +
                    'Please update your version of Node.',
            ),
        );
        process.exit(1);
    }
}

export function checkThatNpmCanReadCwd() {
    const cwd = process.cwd();
    let childOutput = null;
    try {
        childOutput = spawn.sync('npm', ['config', 'list']).output.join('');
    } catch (err: any) {
        return true;
    }
    if (typeof childOutput !== 'string') {
        return true;
    }
    const lines = childOutput.split('\n');
    const prefix = '; cwd = ';
    const line = lines.find(l => l.indexOf(prefix) === 0);
    if (typeof line !== 'string') {
        return true;
    }
    const npmCWD = line.substring(prefix.length);
    if (npmCWD === cwd) {
        return true;
    }
    log(
        pc.red(
            'Could not start an npm process in the right directory.\n\n' +
                `The current directory is: ${pc.bold(cwd)}\n` +
                `However, a newly started npm process runs in: ${pc.bold(npmCWD)}\n\n` +
                'This is probably caused by a misconfigured system terminal shell.',
        ),
    );
    if (process.platform === 'win32') {
        log(
            pc.red('On Windows, this can usually be fixed by running:\n\n') +
                `  ${pc.cyan('reg')} delete "HKCU\\Software\\Microsoft\\Command Processor" /v AutoRun /f\n` +
                `  ${pc.cyan(
                    'reg',
                )} delete "HKLM\\Software\\Microsoft\\Command Processor" /v AutoRun /f\n\n` +
                pc.red('Try to run the above two lines in the terminal.\n') +
                pc.red(
                    'To learn more about this problem, read: https://blogs.msdn.microsoft.com/oldnewthing/20071121-00/?p=24433/',
                ),
        );
    }
    return false;
}

/**
 * Install packages with the selected package manager.
 */
export function installPackages(options: {
    dependencies: string[];
    isDevDependencies?: boolean;
    packageManager?: PackageManager;
    logLevel: CliLogLevel;
    cwd?: string;
}): Promise<void> {
    const { dependencies, isDevDependencies = false, packageManager = 'pnpm', logLevel, cwd } = options;
    return new Promise((resolve, reject) => {
        const command = packageManager;
        const args: string[] = [];

        if (dependencies.length === 0) {
            args.push('install');
            if (packageManager === 'npm') {
                args.push('--loglevel', 'error');
            }
        } else if (packageManager === 'pnpm') {
            args.push('add');
            if (isDevDependencies) {
                args.push('-D');
            }
            args.push('--save-exact', ...dependencies);
        } else {
            args.push('install', '--save', '--save-exact', '--loglevel', 'error', ...dependencies);
            if (isDevDependencies) {
                args.push('--save-dev');
            }
        }

        if (logLevel === 'verbose' && packageManager === 'npm') {
            args.push('--verbose');
        }

        const child = spawn(command, args, {
            stdio: logLevel === 'verbose' ? 'inherit' : 'ignore',
            cwd,
        });
        child.on('close', code => {
            if (code !== 0) {
                let message = 'An error occurred when installing dependencies.';
                if (logLevel === 'silent') {
                    message += ' Try running with `--log-level verbose` to diagnose.';
                }
                reject({ message, command: `${command} ${args.join(' ')}` });
                return;
            }
            resolve();
        });
    });
}

/**
 * Returns the Hexos dependencies to install based on the selected LLM provider.
 */
export function getHexosDependencies(llmProvider: LLMProvider): {
    dependencies: string[];
    devDependencies: string[];
} {
    const dependencies = [
        `@hexos/react-core@${HEXOS_VERSION}`,
        `@hexos/react-ui@${HEXOS_VERSION}`,
        `@hexos/runtime@${HEXOS_VERSION}`,
        `next@${NEXTJS_VERSION}`,
        `react@${REACT_VERSION}`,
        `react-dom@${REACT_VERSION}`,
        `jotai@2.10.0`,
        `zod@3.25.76`,
    ];

    const devDependencies = [
        `typescript@${TYPESCRIPT_VERSION}`,
        `@types/node@22.0.0`,
        `@types/react@19.0.0`,
        `@types/react-dom@19.0.0`,
    ];

    return { dependencies, devDependencies };
}

/**
 * Checks if the response from a Clack prompt was a cancellation symbol, and if so,
 * ends the interactive process.
 */
export function checkCancel<T>(value: T | symbol): value is T {
    if (isCancel(value)) {
        cancel('Setup cancelled.');
        process.exit(0);
    }
    return true;
}

/**
 * Install dependencies with a spinner UI.
 */
export async function installDependenciesWithSpinner(options: {
    dependencies: string[];
    isDevDependencies?: boolean;
    packageManager: PackageManager;
    logLevel: CliLogLevel;
    cwd: string;
    spinnerMessage: string;
    successMessage: string;
    failureMessage: string;
}): Promise<void> {
    const s = spinner();
    s.start(options.spinnerMessage);
    try {
        await installPackages({
            dependencies: options.dependencies,
            isDevDependencies: options.isDevDependencies,
            packageManager: options.packageManager,
            logLevel: options.logLevel,
            cwd: options.cwd,
        });
        s.stop(options.successMessage);
    } catch (e: any) {
        s.stop(pc.red(options.failureMessage));
        log(pc.red(e.message || e.toString()), { level: 'verbose' });
        throw e;
    }
}
